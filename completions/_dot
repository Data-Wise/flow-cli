#compdef dot

# Completion for dot command - dotfile management dispatcher

_dot() {
  local -a subcommands
  local -a files
  local -a secrets

  # Subcommands
  subcommands=(
    'status:Show dotfile sync status'
    's:Show dotfile sync status (alias)'
    'help:Show help message'
    'version:Show version information'
    'add:Add file to chezmoi'
    'edit:Edit a dotfile with preview (auto-add/create)'
    'e:Edit a dotfile (alias)'
    'sync:Pull changes from remote'
    'pull:Pull changes from remote (alias)'
    'push:Push changes to remote'
    'p:Push changes to remote (alias)'
    'diff:Show pending changes'
    'd:Show pending changes (alias)'
    'apply:Apply pending changes'
    'a:Apply pending changes (alias)'
    'unlock:Unlock Bitwarden vault'
    'u:Unlock Bitwarden vault (alias)'
    'secret:macOS Keychain secret management'
    'ignore:Manage .chezmoiignore patterns'
    'size:Analyze repository size'
    'doctor:Run diagnostics'
    'dr:Run diagnostics (alias)'
    'undo:Rollback last apply'
    'init:Initialize dotfile management'
  )

  # Get managed files if chezmoi is available
  if command -v chezmoi &>/dev/null; then
    local managed_files
    managed_files=(${(f)"$(chezmoi managed 2>/dev/null)"})
    for f in $managed_files; do
      # Add both full path and basename for fuzzy matching
      files+=("${f:t}:${f}")
    done
  fi

  # Get Bitwarden items if vault is unlocked
  if command -v bw &>/dev/null && [[ -n "$BW_SESSION" ]]; then
    local items_output
    items_output=$(bw list items --session "$BW_SESSION" 2>/dev/null)
    if [[ $? -eq 0 ]] && command -v jq &>/dev/null; then
      secrets=(${(f)"$(echo "$items_output" | jq -r '.[].name' 2>/dev/null)"})
    fi
  fi

  _arguments -C \
    '1:subcommand:->subcommand' \
    '*::arg:->args' \
  && return 0

  case "$state" in
    subcommand)
      _describe -t subcommands 'dot subcommand' subcommands
      ;;
    args)
      case "$line[1]" in
        add)
          # Complete file paths (for files not yet tracked)
          _files
          ;;
        edit|e)
          # Complete both managed files AND file paths (for auto-add/create)
          _alternative \
            'files:managed file:_describe -t files managed\ file files' \
            'paths:file path:_files'
          ;;
        diff|d|apply|a)
          _describe -t files 'managed file' files
          ;;
        ignore)
          # Ignore pattern management subcommands
          if [[ ${#line[@]} -eq 1 ]]; then
            local -a ignore_cmds
            ignore_cmds=(
              'add:Add ignore pattern'
              'list:List all patterns'
              'ls:List all patterns (alias)'
              'remove:Remove ignore pattern'
              'rm:Remove ignore pattern (alias)'
              'edit:Edit .chezmoiignore in $EDITOR'
              'help:Show ignore command help'
            )
            _describe -t ignore 'ignore command' ignore_cmds
          fi
          ;;
        secret)
          # Keychain secret commands
          if [[ ${#line[@]} -eq 1 ]]; then
            local -a secret_cmds
            secret_cmds=(
              'add:Store a secret in Keychain'
              'get:Retrieve a secret from Keychain'
              'list:List all Keychain secrets'
              'delete:Remove a secret from Keychain'
              'import:Import secrets from Bitwarden'
              'bw:Access Bitwarden cloud secrets (fallback)'
              'help:Show help'
            )
            _describe -t secrets 'secret command' secret_cmds
          elif [[ "$line[2]" == "bw" ]]; then
            # Bitwarden subcommands
            local -a bw_cmds
            bw_cmds=(
              'list:List Bitwarden items'
              'add:Add to Bitwarden'
              'check:Check expiring secrets'
            )
            if [[ ${#secrets[@]} -gt 0 ]]; then
              for s in $secrets; do
                bw_cmds+=("$s:Retrieve from Bitwarden")
              done
            fi
            _describe -t secrets 'bw command or secret name' bw_cmds
          fi
          ;;
      esac
      ;;
  esac
}

_dot "$@"
