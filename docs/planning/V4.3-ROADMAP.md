# v4.3.0+ Roadmap

**Created:** 2025-12-29
**Status:** In Progress
**Last Updated:** 2025-12-30

This document contains detailed implementation plans for future flow-cli enhancements.

---

## Overview

After completing v4.2.0 (Worktree + Claude Integration), these are the prioritized enhancements for future versions.

| Priority | Feature | Effort | Value | Status |
|----------|---------|--------|-------|--------|
| P1 | cc wt status | ~1 hour | High | ‚úÖ Done |
| P1 | cc wt clean | ~45 min | High | See wt prune |
| P2 | g feature prune --force | ~30 min | Medium | ‚úÖ Done |
| P2 | g feature prune --older-than | ~1 hour | Medium | Pending |
| P2 | g feature status | ~45 min | Medium | Pending |
| P3 | wt prune | ~1 hour | Medium | ‚úÖ Done |
| P3 | wt status | ~30 min | Low | Pending |
| P4 | Remote sync | TBD | Future | Pending |

### v4.3.0 Completed Features

- **cc wt status** - Shows worktrees with Claude session info (green/yellow/white indicators)
- **g feature prune --force** - Adds confirmation prompt by default, `--force` to skip
- **wt prune** - Comprehensive cleanup: prunes stale refs + removes merged worktrees + optionally deletes branches

---

## Priority 1: CC Worktree Enhancements

### cc wt status (~1 hour)

**Purpose:** Show all worktrees with Claude session information.

**User Story:** As a developer, I want to see which worktrees have active Claude sessions so I can manage my parallel work contexts.

**Implementation:**

```zsh
# In lib/dispatchers/cc-dispatcher.zsh

_cc_worktree_status() {
    local worktree_dir="${FLOW_WORKTREE_DIR:-$(_flow_find_project_root)/.worktrees}"

    echo "üå≥ Worktree Status"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

    # Get all worktrees
    git worktree list --porcelain | while read line; do
        if [[ "$line" == worktree\ * ]]; then
            local wt_path="${line#worktree }"
            local branch=$(git -C "$wt_path" branch --show-current 2>/dev/null)

            # Check for Claude session
            local session_info=""
            if [[ -f "$wt_path/.claude/session.json" ]]; then
                local last_active=$(jq -r '.last_active // empty' "$wt_path/.claude/session.json" 2>/dev/null)
                local model=$(jq -r '.model // "unknown"' "$wt_path/.claude/session.json" 2>/dev/null)
                session_info="ü§ñ $model (${last_active:-unknown})"
            fi

            printf "  %-30s %s\n" "$branch" "$session_info"
        fi
    done
}
```

**Tests to add:**
- `test_cc_wt_status_shows_worktrees`
- `test_cc_wt_status_shows_claude_sessions`
- `test_cc_wt_status_handles_no_sessions`

---

### cc wt clean (~45 min)

**Purpose:** Remove worktrees for merged branches.

**User Story:** As a developer, I want to clean up worktrees for branches that have been merged so I don't accumulate stale directories.

**Implementation:**

```zsh
# In lib/dispatchers/cc-dispatcher.zsh

_cc_worktree_clean() {
    local dry_run=false
    [[ "$1" == "-n" || "$1" == "--dry-run" ]] && dry_run=true

    echo "üßπ Cleaning merged worktrees..."

    # Get merged branches
    local merged_branches=$(git branch --merged dev 2>/dev/null | grep -E "^\s*feature/" | tr -d ' ')

    git worktree list --porcelain | while read line; do
        if [[ "$line" == worktree\ * ]]; then
            local wt_path="${line#worktree }"
            local branch=$(git -C "$wt_path" branch --show-current 2>/dev/null)

            if echo "$merged_branches" | grep -q "^$branch$"; then
                if $dry_run; then
                    echo "  Would remove: $wt_path ($branch)"
                else
                    echo "  Removing: $wt_path ($branch)"
                    git worktree remove "$wt_path" 2>/dev/null
                fi
            fi
        fi
    done

    # Also run g feature prune
    if ! $dry_run; then
        g feature prune
    fi
}
```

**Integration:** Combines with `g feature prune` for complete cleanup.

---

## Priority 2: Branch Management

### g feature prune --force (~30 min)

**Purpose:** Skip confirmation for non-interactive use.

**User Story:** As a developer using CI/automation, I want to prune branches without interactive prompts.

**Implementation:**

```zsh
# In lib/dispatchers/g-dispatcher.zsh, modify _g_feature_prune()

_g_feature_prune() {
    local force=false
    local dry_run=false
    local clean_remote=false

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --force|-f) force=true; shift ;;
            -n|--dry-run) dry_run=true; shift ;;
            --all|-a) clean_remote=true; shift ;;
            *) shift ;;
        esac
    done

    # ... existing logic ...

    # Skip confirmation if force is set
    if ! $force && ! $dry_run; then
        echo -n "Delete ${#to_delete[@]} branches? [y/N] "
        read -r confirm
        [[ "$confirm" != [yY]* ]] && return 0
    fi

    # ... delete logic ...
}
```

**Tests:**
- `test_g_feature_prune_force_skips_confirmation`
- `test_g_feature_prune_force_with_dry_run`

---

### g feature prune --older-than (~1 hour)

**Purpose:** Filter branches by age.

**User Story:** As a developer, I want to only prune branches older than a certain age to avoid accidentally removing recent work.

**Implementation:**

```zsh
# Add to _g_feature_prune()

# Parse duration: 30d ‚Üí 30 days, 1w ‚Üí 7 days, 2m ‚Üí 60 days
_parse_duration() {
    local duration="$1"
    case "$duration" in
        *d) echo "${duration%d}" ;;
        *w) echo "$((${duration%w} * 7))" ;;
        *m) echo "$((${duration%m} * 30))" ;;
        *) echo "0" ;;
    esac
}

_g_feature_prune() {
    local max_age_days=0

    # Parse --older-than flag
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --older-than)
                max_age_days=$(_parse_duration "$2")
                shift 2
                ;;
            # ... other flags ...
        esac
    done

    # Filter by age
    local now=$(date +%s)
    local cutoff=$((now - max_age_days * 86400))

    for branch in $merged_branches; do
        local commit_time=$(git log -1 --format=%ct "$branch" 2>/dev/null)
        if [[ $max_age_days -eq 0 ]] || [[ $commit_time -lt $cutoff ]]; then
            to_delete+=("$branch")
        fi
    done
}
```

**Usage:**
```bash
g feature prune --older-than 30d  # Only branches > 30 days old
g feature prune --older-than 1w   # Only branches > 1 week old
g feature prune --older-than 2m   # Only branches > 2 months old
```

---

### g feature status (~45 min)

**Purpose:** Show overview of all feature branches with their status.

**User Story:** As a developer, I want to see which feature branches are merged, unmerged, and how old they are.

**Implementation:**

```zsh
# In lib/dispatchers/g-dispatcher.zsh

_g_feature_status() {
    local base_branch="${1:-dev}"

    echo "üìä Feature Branch Status"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

    echo ""
    echo "üßπ Stale branches (merged to $base_branch):"
    git branch --merged "$base_branch" 2>/dev/null | while read branch; do
        branch="${branch#* }"
        [[ "$branch" == feature/* || "$branch" == hotfix/* ]] || continue
        local age=$(git log -1 --format="%cr" "$branch" 2>/dev/null)
        printf "  %-40s %s\n" "$branch" "($age)"
    done

    echo ""
    echo "‚ö†Ô∏è  Active branches (not merged to $base_branch):"
    git branch --no-merged "$base_branch" 2>/dev/null | while read branch; do
        branch="${branch#* }"
        [[ "$branch" == feature/* || "$branch" == hotfix/* ]] || continue
        local commits=$(git rev-list --count "$base_branch".."$branch" 2>/dev/null)
        local age=$(git log -1 --format="%cr" "$branch" 2>/dev/null)
        printf "  %-40s %d commits ahead (%s)\n" "$branch" "$commits" "$age"
    done

    echo ""
    echo "üí° Tip: Run 'g feature prune' to clean up merged branches"
}
```

**Output example:**
```
üìä Feature Branch Status
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üßπ Stale branches (merged to dev):
  feature/old-feature                      (3 weeks ago)
  feature/completed-task                   (5 days ago)

‚ö†Ô∏è  Active branches (not merged to dev):
  feature/work-in-progress                 12 commits ahead (2 hours ago)
  feature/new-feature                      3 commits ahead (1 day ago)

üí° Tip: Run 'g feature prune' to clean up merged branches
```

---

## Priority 3: Worktree Improvements

### wt prune (~1 hour)

**Purpose:** Combined cleanup for worktrees and branches.

**User Story:** As a developer, I want one command to clean up both stale worktrees and merged branches.

**Implementation:**

```zsh
# In lib/dispatchers/wt-dispatcher.zsh

_wt_prune() {
    local branches_only=false
    local worktrees_only=false
    local dry_run=false

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --branches-only) branches_only=true; shift ;;
            --worktrees-only) worktrees_only=true; shift ;;
            -n|--dry-run) dry_run=true; shift ;;
            *) shift ;;
        esac
    done

    echo "üßπ Pruning worktrees and branches..."
    echo ""

    # Prune stale worktrees
    if ! $branches_only; then
        echo "Pruning stale worktrees..."
        if $dry_run; then
            git worktree prune --dry-run
        else
            git worktree prune
        fi
    fi

    # Prune merged branches
    if ! $worktrees_only; then
        echo ""
        echo "Pruning merged branches..."
        if $dry_run; then
            g feature prune -n
        else
            g feature prune --force
        fi
    fi

    echo ""
    echo "‚úÖ Cleanup complete"
}
```

**Usage:**
```bash
wt prune                  # Clean both worktrees and branches
wt prune --branches-only  # Only clean branches
wt prune --worktrees-only # Only clean worktrees
wt prune -n               # Dry run
```

---

### wt status (~30 min)

**Purpose:** Show worktree health and disk usage.

**User Story:** As a developer, I want to see disk usage and health of my worktrees.

**Implementation:**

```zsh
# In lib/dispatchers/wt-dispatcher.zsh

_wt_status() {
    echo "üå≥ Worktree Status"
    echo "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"

    local total_size=0

    git worktree list --porcelain | while read line; do
        if [[ "$line" == worktree\ * ]]; then
            local wt_path="${line#worktree }"
            local branch=$(git -C "$wt_path" branch --show-current 2>/dev/null || echo "detached")
            local size=$(du -sh "$wt_path" 2>/dev/null | cut -f1)
            local status=""

            # Check if branch is merged
            if git branch --merged dev 2>/dev/null | grep -q "$branch"; then
                status="üßπ merged"
            elif [[ ! -d "$wt_path/.git" && ! -f "$wt_path/.git" ]]; then
                status="‚ö†Ô∏è  stale"
            else
                status="‚úÖ active"
            fi

            printf "  %-30s %-10s %-6s %s\n" "$branch" "$status" "$size" "$wt_path"
        fi
    done

    echo ""
    echo "üí° Run 'wt prune' to clean up stale worktrees"
}
```

---

## Priority 4: Remote & Team Features (Future)

These are longer-term features that require more design work.

### Remote State Sync

**Concept:** Optional cloud backup for session state, wins, and goals.

**Considerations:**
- Privacy: User data should be encrypted
- Conflict resolution: How to handle multi-device edits
- Storage: Where to store (GitHub Gist? Private repo? Cloud service?)

### Multi-Device Support

**Concept:** Sync flow-cli state across multiple machines.

**Considerations:**
- Real-time sync vs. manual sync
- Merge conflicts for .STATUS files
- Session handoff between devices

### Shared Templates

**Concept:** Team-wide project templates and configurations.

**Considerations:**
- Template repository format
- Versioning and updates
- Private vs. public templates

---

## Implementation Notes

### Key Learnings from v4.2.0

1. **ZSH path array conflict:** In ZSH, `local path` shadows the global `path` array (tied to `PATH`). Always use `local result_path` or similar naming.

2. **Test isolation:** Create temporary git repos for tests to avoid polluting real repos.

3. **Mode chaining pattern:** When implementing mode flags (yolo, plan, opus), parse them first, then pass remaining args to the action.

### Testing Strategy

- Unit tests for individual functions
- E2E tests with mock `claude()` function
- Interactive dogfooding tests for UX validation

### Documentation Updates

When implementing new features:
1. Update `lib/dispatchers/*-dispatcher.zsh`
2. Update help function `_<cmd>_help()`
3. Add tests in `tests/`
4. Update `docs/reference/DISPATCHER-REFERENCE.md`
5. Update `docs/reference/COMMAND-QUICK-REFERENCE.md`
6. Update `CLAUDE.md` roadmap section

---

## Version Planning

| Version | Features | Target |
|---------|----------|--------|
| v4.3.0 | cc wt status, cc wt clean | When needed |
| v4.4.0 | g feature enhancements | When needed |
| v4.5.0 | wt prune, wt status | When needed |
| v5.0.0 | Remote sync (if implemented) | Future |

**Philosophy:** Only implement features when there's a real need. Avoid premature optimization or feature creep.

---

**Last Updated:** 2025-12-29
