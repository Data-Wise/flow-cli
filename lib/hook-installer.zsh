# hook-installer.zsh - Git hook installation and version management
# Provides: _install_git_hooks, _upgrade_git_hooks, _check_hook_version

# ============================================================================
# CONFIGURATION
# ============================================================================

# Hook version (semantic versioning)
typeset -g FLOW_HOOK_VERSION="1.0.0"

# Hook template directory (relative to this file)
typeset -g FLOW_HOOK_TEMPLATE_DIR="${0:A:h}/hooks"

# Hook names to install
typeset -a FLOW_HOOKS
FLOW_HOOKS=(
  "pre-commit"
  "pre-push"
  "prepare-commit-msg"
)

# ============================================================================
# VERSION MANAGEMENT
# ============================================================================

# Extract version from installed hook file
_get_installed_hook_version() {
  local hook_file="$1"

  if [[ ! -f "$hook_file" ]]; then
    echo "0.0.0"
    return 1
  fi

  # Extract version from comment: # Version: X.Y.Z
  local version
  version=$(grep '^# Version:' "$hook_file" | head -1 | awk '{print $3}')

  if [[ -z "$version" ]]; then
    echo "0.0.0"
    return 1
  fi

  echo "$version"
  return 0
}

# Compare two semantic versions (X.Y.Z)
# Returns: 0 if v1 == v2, 1 if v1 > v2, 2 if v1 < v2
_compare_versions() {
  local v1="$1"
  local v2="$2"

  # Split versions into components
  local -a v1_parts v2_parts
  v1_parts=(${(@s:.:)v1})
  v2_parts=(${(@s:.:)v2})

  # Compare major, minor, patch
  for i in {1..3}; do
    local v1_part="${v1_parts[$i]:-0}"
    local v2_part="${v2_parts[$i]:-0}"

    if [[ $v1_part -gt $v2_part ]]; then
      return 1  # v1 > v2
    elif [[ $v1_part -lt $v2_part ]]; then
      return 2  # v1 < v2
    fi
  done

  return 0  # v1 == v2
}

# Check if hook needs upgrade
_check_hook_version() {
  local hook_name="$1"
  local git_root
  git_root=$(git rev-parse --show-toplevel 2>/dev/null)

  if [[ -z "$git_root" ]]; then
    _flow_log_error "Not in a git repository"
    return 1
  fi

  local hook_file="${git_root}/.git/hooks/${hook_name}"
  local installed_version
  installed_version=$(_get_installed_hook_version "$hook_file")

  _compare_versions "$installed_version" "$FLOW_HOOK_VERSION"
  local cmp_result=$?

  case $cmp_result in
    0)
      _flow_log_info "${hook_name}: up to date (v${installed_version})"
      return 0
      ;;
    1)
      _flow_log_warning "${hook_name}: newer version installed (v${installed_version} > v${FLOW_HOOK_VERSION})"
      return 0
      ;;
    2)
      _flow_log_warning "${hook_name}: upgrade available (v${installed_version} → v${FLOW_HOOK_VERSION})"
      return 1
      ;;
  esac
}

# ============================================================================
# HOOK INSTALLATION
# ============================================================================

# Install a single hook
_install_single_hook() {
  local hook_name="$1"
  local git_root="$2"
  local force="${3:-0}"

  local template_file="${FLOW_HOOK_TEMPLATE_DIR}/${hook_name}-template.zsh"
  local hook_file="${git_root}/.git/hooks/${hook_name}"

  # Verify template exists
  if [[ ! -f "$template_file" ]]; then
    _flow_log_error "Template not found: ${template_file}"
    return 1
  fi

  # Check if hook already exists
  if [[ -f "$hook_file" ]] && [[ $force -eq 0 ]]; then
    local installed_version
    installed_version=$(_get_installed_hook_version "$hook_file")

    _compare_versions "$installed_version" "$FLOW_HOOK_VERSION"
    local cmp_result=$?

    if [[ $cmp_result -eq 0 ]]; then
      _flow_log_info "${hook_name}: already installed (v${installed_version})"
      return 0
    elif [[ $cmp_result -eq 1 ]]; then
      _flow_log_warning "${hook_name}: newer version installed (v${installed_version})"
      _flow_log_muted "   Use --force to downgrade"
      return 0
    else
      _flow_log_info "${hook_name}: upgrading v${installed_version} → v${FLOW_HOOK_VERSION}"
    fi
  fi

  # Create hooks directory if needed
  mkdir -p "${git_root}/.git/hooks"

  # Backup existing hook if not flow-managed
  if [[ -f "$hook_file" ]]; then
    if ! grep -q "Auto-generated by: teach hooks install" "$hook_file"; then
      local backup_file="${hook_file}.backup-$(date +%Y%m%d-%H%M%S)"
      cp "$hook_file" "$backup_file"
      _flow_log_info "Backed up existing hook to: ${backup_file:t}"
    fi
  fi

  # Copy template to hook file
  cp "$template_file" "$hook_file"

  # Make executable
  chmod +x "$hook_file"

  _flow_log_success "Installed ${hook_name} (v${FLOW_HOOK_VERSION})"
  return 0
}

# Install all hooks
_install_git_hooks() {
  local force=0

  # Parse options
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --force|-f)
        force=1
        shift
        ;;
      *)
        shift
        ;;
    esac
  done

  # Verify we're in a git repository
  local git_root
  git_root=$(git rev-parse --show-toplevel 2>/dev/null)

  if [[ -z "$git_root" ]]; then
    _flow_log_error "Not in a git repository"
    _flow_log_muted "   Run from within a git-tracked project"
    return 1
  fi

  # Check if this is a Quarto project
  if [[ ! -f "${git_root}/_quarto.yml" ]]; then
    _flow_log_error "Not a Quarto project"
    _flow_log_muted "   _quarto.yml not found"
    return 1
  fi

  _flow_log_info "Installing git hooks for Quarto workflow..."
  echo ""

  local installed=0
  local failed=0

  for hook_name in "${FLOW_HOOKS[@]}"; do
    if _install_single_hook "$hook_name" "$git_root" "$force"; then
      ((installed++))
    else
      ((failed++))
    fi
  done

  echo ""

  if [[ $failed -gt 0 ]]; then
    _flow_log_error "Installation completed with errors: $installed installed, $failed failed"
    return 1
  else
    _flow_log_success "All hooks installed successfully ($installed hooks)"

    # Show configuration options
    echo ""
    _flow_log_info "Configuration options:"
    _flow_log_muted "   QUARTO_PRE_COMMIT_RENDER=1    # Enable full rendering on commit"
    _flow_log_muted "   QUARTO_PARALLEL_RENDER=1      # Enable parallel rendering (default: on)"
    _flow_log_muted "   QUARTO_MAX_PARALLEL=4         # Max parallel jobs (default: 4)"
    _flow_log_muted "   QUARTO_COMMIT_TIMING=1        # Add timing to commit messages (default: on)"
    _flow_log_muted "   QUARTO_COMMIT_SUMMARY=1       # Add validation summary to commits"

    echo ""
    _flow_log_info "To set environment variables:"
    _flow_log_muted "   export QUARTO_PRE_COMMIT_RENDER=1"
    _flow_log_muted "   # Or add to ~/.zshrc for persistence"

    return 0
  fi
}

# ============================================================================
# HOOK UPGRADE
# ============================================================================

_upgrade_git_hooks() {
  local git_root
  git_root=$(git rev-parse --show-toplevel 2>/dev/null)

  if [[ -z "$git_root" ]]; then
    _flow_log_error "Not in a git repository"
    return 1
  fi

  _flow_log_info "Checking for hook upgrades..."
  echo ""

  local upgradeable=()
  local up_to_date=()

  for hook_name in "${FLOW_HOOKS[@]}"; do
    _compare_versions \
      "$(_get_installed_hook_version "${git_root}/.git/hooks/${hook_name}")" \
      "$FLOW_HOOK_VERSION"
    local cmp_result=$?

    if [[ $cmp_result -eq 2 ]]; then
      upgradeable+=("$hook_name")
    else
      up_to_date+=("$hook_name")
    fi
  done

  if [[ ${#upgradeable[@]} -eq 0 ]]; then
    _flow_log_success "All hooks are up to date"
    return 0
  fi

  _flow_log_info "Hooks to upgrade: ${#upgradeable[@]}"
  for hook_name in "${upgradeable[@]}"; do
    local current_version
    current_version=$(_get_installed_hook_version "${git_root}/.git/hooks/${hook_name}")
    _flow_log_muted "   - ${hook_name} (v${current_version} → v${FLOW_HOOK_VERSION})"
  done

  echo ""
  local response
  read "response?Upgrade these hooks? [Y/n] "

  if [[ "$response" =~ ^[Nn]$ ]]; then
    _flow_log_info "Upgrade cancelled"
    return 0
  fi

  echo ""
  local upgraded=0
  local failed=0

  for hook_name in "${upgradeable[@]}"; do
    if _install_single_hook "$hook_name" "$git_root" 1; then
      ((upgraded++))
    else
      ((failed++))
    fi
  done

  echo ""

  if [[ $failed -gt 0 ]]; then
    _flow_log_error "Upgrade completed with errors: $upgraded upgraded, $failed failed"
    return 1
  else
    _flow_log_success "All hooks upgraded successfully ($upgraded hooks)"
    return 0
  fi
}

# ============================================================================
# HOOK UNINSTALL
# ============================================================================

_uninstall_git_hooks() {
  local git_root
  git_root=$(git rev-parse --show-toplevel 2>/dev/null)

  if [[ -z "$git_root" ]]; then
    _flow_log_error "Not in a git repository"
    return 1
  fi

  _flow_log_warning "This will remove all flow-cli managed hooks"

  local response
  read "response?Continue? [y/N] "

  if [[ ! "$response" =~ ^[Yy]$ ]]; then
    _flow_log_info "Uninstall cancelled"
    return 0
  fi

  echo ""
  local removed=0

  for hook_name in "${FLOW_HOOKS[@]}"; do
    local hook_file="${git_root}/.git/hooks/${hook_name}"

    if [[ -f "$hook_file" ]]; then
      if grep -q "Auto-generated by: teach hooks install" "$hook_file"; then
        rm -f "$hook_file"
        _flow_log_success "Removed ${hook_name}"
        ((removed++))
      else
        _flow_log_warning "Skipped ${hook_name} (not flow-managed)"
      fi
    fi
  done

  echo ""

  if [[ $removed -gt 0 ]]; then
    _flow_log_success "Uninstalled $removed hook(s)"
  else
    _flow_log_info "No flow-managed hooks found"
  fi

  return 0
}

# ============================================================================
# HOOK STATUS
# ============================================================================

_check_all_hooks() {
  local git_root
  git_root=$(git rev-parse --show-toplevel 2>/dev/null)

  if [[ -z "$git_root" ]]; then
    _flow_log_error "Not in a git repository"
    return 1
  fi

  _flow_log_info "Hook status:"
  echo ""

  local installed=0
  local missing=0
  local outdated=0

  for hook_name in "${FLOW_HOOKS[@]}"; do
    local hook_file="${git_root}/.git/hooks/${hook_name}"

    if [[ ! -f "$hook_file" ]]; then
      _flow_log_error "${hook_name}: not installed"
      ((missing++))
      continue
    fi

    if ! grep -q "Auto-generated by: teach hooks install" "$hook_file"; then
      _flow_log_warning "${hook_name}: exists but not flow-managed"
      continue
    fi

    local current_version
    current_version=$(_get_installed_hook_version "$hook_file")

    _compare_versions "$current_version" "$FLOW_HOOK_VERSION"
    local cmp_result=$?

    case $cmp_result in
      0)
        _flow_log_success "${hook_name}: v${current_version} (up to date)"
        ((installed++))
        ;;
      1)
        _flow_log_info "${hook_name}: v${current_version} (newer than v${FLOW_HOOK_VERSION})"
        ((installed++))
        ;;
      2)
        _flow_log_warning "${hook_name}: v${current_version} (upgrade to v${FLOW_HOOK_VERSION})"
        ((outdated++))
        ;;
    esac
  done

  echo ""

  # Summary
  _flow_log_info "Summary: $installed up to date, $outdated outdated, $missing missing"

  if [[ $outdated -gt 0 ]]; then
    echo ""
    _flow_log_info "Run ${FLOW_COLORS[bold]}teach hooks upgrade${FLOW_COLORS[reset]} to update outdated hooks"
  fi

  if [[ $missing -gt 0 ]]; then
    echo ""
    _flow_log_info "Run ${FLOW_COLORS[bold]}teach hooks install${FLOW_COLORS[reset]} to install missing hooks"
  fi

  return 0
}

# Export functions for use by teach dispatcher
typeset -g _FLOW_HOOK_INSTALLER_LOADED=1
