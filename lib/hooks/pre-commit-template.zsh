#!/usr/bin/env zsh
# Pre-commit hook for Quarto teaching projects
# Auto-generated by: teach hooks install
# Version: 1.0.0
# DO NOT EDIT - This file is managed by flow-cli

# ============================================================================
# CONFIGURATION
# ============================================================================

# Enable full rendering on commit (default: off)
# Set QUARTO_PRE_COMMIT_RENDER=1 to enable
QUARTO_PRE_COMMIT_RENDER="${QUARTO_PRE_COMMIT_RENDER:-0}"

# Enable parallel rendering for multiple files (default: on)
QUARTO_PARALLEL_RENDER="${QUARTO_PARALLEL_RENDER:-1}"

# Maximum parallel jobs (default: 4)
QUARTO_MAX_PARALLEL="${QUARTO_MAX_PARALLEL:-4}"

# Colors for output
typeset -gA COLORS
COLORS=(
  [reset]='\033[0m'
  [bold]='\033[1m'
  [success]='\033[38;5;114m'
  [warning]='\033[38;5;221m'
  [error]='\033[38;5;203m'
  [info]='\033[38;5;117m'
  [muted]='\033[38;5;245m'
)

# ============================================================================
# LOGGING HELPERS
# ============================================================================

_log_success() { echo -e "${COLORS[success]}✓ $*${COLORS[reset]}" }
_log_warning() { echo -e "${COLORS[warning]}⚠ $*${COLORS[reset]}" }
_log_error()   { echo -e "${COLORS[error]}✗ $*${COLORS[reset]}" }
_log_info()    { echo -e "${COLORS[info]}ℹ $*${COLORS[reset]}" }
_log_muted()   { echo -e "${COLORS[muted]}$*${COLORS[reset]}" }

# ============================================================================
# LAYER 1: YAML FRONTMATTER VALIDATION
# ============================================================================

_validate_yaml() {
  local file="$1"
  local filename="${file:t}"

  # Check for YAML frontmatter delimiter
  if ! grep -q '^---' "$file"; then
    _log_error "No YAML frontmatter found in $filename"
    _log_muted "   Expected: --- at start of file"
    return 1
  fi

  # Extract YAML frontmatter (between first two --- delimiters)
  local yaml_content
  yaml_content=$(awk '/^---$/{if(++count==2) exit; next} count==1' "$file")

  if [[ -z "$yaml_content" ]]; then
    _log_error "Empty YAML frontmatter in $filename"
    return 1
  fi

  # Validate YAML syntax using yq
  if ! command -v yq &>/dev/null; then
    _log_warning "yq not found - skipping YAML validation for $filename"
    return 0
  fi

  if ! echo "$yaml_content" | yq eval . &>/dev/null; then
    _log_error "Invalid YAML syntax in $filename"
    _log_muted "   Run: yq eval . $file"
    return 1
  fi

  return 0
}

# ============================================================================
# LAYER 2: QUARTO SYNTAX CHECK
# ============================================================================

_validate_syntax() {
  local file="$1"
  local filename="${file:t}"

  if ! command -v quarto &>/dev/null; then
    _log_warning "Quarto not found - skipping syntax validation"
    return 0
  fi

  local output
  output=$(quarto inspect "$file" 2>&1)
  local status=$?

  if [[ $status -ne 0 ]]; then
    _log_error "Quarto syntax error in $filename"
    _log_muted "   Output: $output"
    return 1
  fi

  return 0
}

# ============================================================================
# LAYER 3: FULL RENDER (OPTIONAL)
# ============================================================================

_render_file() {
  local file="$1"
  local filename="${file:t}"

  # Skip if rendering not enabled
  if [[ "${QUARTO_PRE_COMMIT_RENDER}" != "1" ]]; then
    return 0
  fi

  if ! command -v quarto &>/dev/null; then
    _log_warning "Quarto not found - skipping render"
    return 0
  fi

  _log_info "Rendering $filename..."

  local output
  output=$(quarto render "$file" --quiet 2>&1)
  local status=$?

  if [[ $status -ne 0 ]]; then
    _log_error "Render failed for $filename"
    _log_muted "   Output: $output"
    return 1
  fi

  _log_success "Rendered $filename"
  return 0
}

# ============================================================================
# LAYER 4: EMPTY CODE CHUNK DETECTION (WARNING)
# ============================================================================

_check_empty_chunks() {
  local file="$1"
  local filename="${file:t}"

  # Match empty R/Python code chunks
  # Pattern: ```{r} ``` or ```{python} ``` with only whitespace between
  local empty_chunks
  empty_chunks=$(grep -n -E '```\{(r|python)[^}]*\}\s*```' "$file")

  if [[ -n "$empty_chunks" ]]; then
    _log_warning "Empty code chunks in $filename:"
    echo "$empty_chunks" | while IFS=: read -r line_num content; do
      _log_muted "   Line $line_num: ${content:0:50}..."
    done
    return 1  # Warning, but non-fatal
  fi

  return 0
}

# ============================================================================
# LAYER 5: IMAGE REFERENCE VALIDATION (WARNING)
# ============================================================================

_check_images() {
  local file="$1"
  local filename="${file:t}"
  local file_dir="${file:h}"

  local missing_images=()
  local found_images=0

  # Extract image references: ![alt](path)
  # Also check for: knitr::include_graphics("path")
  local image_refs
  image_refs=$(grep -oE '!\[.*?\]\([^)]+\)|include_graphics\(["\x27]([^"\x27]+)["\x27]\)' "$file" | \
               sed -E 's/.*\(([^)]+)\).*/\1/' | \
               tr -d '"' | tr -d "'")

  if [[ -z "$image_refs" ]]; then
    return 0  # No images to check
  fi

  while IFS= read -r img; do
    [[ -z "$img" ]] && continue

    # Skip URLs
    if [[ "$img" =~ ^https?:// ]]; then
      ((found_images++))
      continue
    fi

    # Check relative to file directory
    local img_path
    if [[ "$img" = /* ]]; then
      img_path="$img"
    else
      img_path="${file_dir}/${img}"
    fi

    if [[ ! -f "$img_path" ]]; then
      missing_images+=("$img")
    else
      ((found_images++))
    fi
  done <<< "$image_refs"

  if [[ ${#missing_images[@]} -gt 0 ]]; then
    _log_warning "Missing image references in $filename:"
    for img in "${missing_images[@]}"; do
      _log_muted "   - $img"
    done
    return 1  # Warning, but non-fatal
  fi

  return 0
}

# ============================================================================
# SPECIAL: _freeze/ COMMIT PREVENTION
# ============================================================================

_check_freeze() {
  local freeze_files
  freeze_files=$(git diff --cached --name-only | grep '^_freeze/')

  if [[ -n "$freeze_files" ]]; then
    _log_error "Cannot commit _freeze/ directory"
    _log_muted "   Files staged:"
    echo "$freeze_files" | while read -r f; do
      _log_muted "     - $f"
    done
    echo ""
    _log_info "To unstage: ${COLORS[bold]}git restore --staged _freeze/${COLORS[reset]}"
    return 1
  fi

  return 0
}

# ============================================================================
# PARALLEL RENDERING
# ============================================================================

_render_files_parallel() {
  local files=("$@")
  local pids=()
  local failed=()
  local max_jobs="${QUARTO_MAX_PARALLEL:-4}"

  _log_info "Rendering ${#files[@]} files in parallel (max $max_jobs jobs)..."

  for file in "${files[@]}"; do
    # Wait if we've reached max parallel jobs
    while [[ ${#pids[@]} -ge $max_jobs ]]; do
      for i in "${!pids[@]}"; do
        if ! kill -0 "${pids[$i]}" 2>/dev/null; then
          wait "${pids[$i]}"
          if [[ $? -ne 0 ]]; then
            failed+=("${files[$i]}")
          fi
          unset "pids[$i]"
        fi
      done
      sleep 0.1
    done

    # Start rendering in background
    (_render_file "$file") &
    pids+=($!)
  done

  # Wait for remaining jobs
  for pid in "${pids[@]}"; do
    wait "$pid" || true
  done

  if [[ ${#failed[@]} -gt 0 ]]; then
    _log_error "Rendering failed for ${#failed[@]} file(s)"
    return 1
  fi

  return 0
}

# ============================================================================
# INTERACTIVE ERROR HANDLING
# ============================================================================

_prompt_commit_anyway() {
  local error_type="$1"

  echo ""
  _log_warning "Validation ${error_type} detected"

  # Read response with timeout (default to 'no' after 30 seconds)
  local response
  read -t 30 "response?Commit anyway? [y/N] "
  local read_status=$?

  # Timeout or error defaults to 'no'
  if [[ $read_status -ne 0 ]]; then
    echo ""
    _log_info "No response - aborting commit"
    return 1
  fi

  # Check for yes response
  if [[ "$response" =~ ^[Yy]$ ]]; then
    _log_info "Proceeding with commit despite ${error_type}..."
    return 0
  fi

  _log_info "Aborting commit"
  return 1
}

# ============================================================================
# MAIN VALIDATION WORKFLOW
# ============================================================================

_validate_file() {
  local file="$1"
  local errors=0
  local warnings=0
  local start_time=$(date +%s)

  _log_info "Validating ${file:t}..."

  # Layer 1: YAML validation (FATAL)
  if ! _validate_yaml "$file"; then
    ((errors++))
  fi

  # Layer 2: Quarto syntax (FATAL)
  if ! _validate_syntax "$file"; then
    ((errors++))
  fi

  # Layer 3: Full render (FATAL if enabled)
  if ! _render_file "$file"; then
    ((errors++))
  fi

  # Layer 4: Empty chunks (WARNING)
  if ! _check_empty_chunks "$file"; then
    ((warnings++))
  fi

  # Layer 5: Image references (WARNING)
  if ! _check_images "$file"; then
    ((warnings++))
  fi

  local end_time=$(date +%s)
  local duration=$((end_time - start_time))

  # Summary
  if [[ $errors -eq 0 ]] && [[ $warnings -eq 0 ]]; then
    _log_success "${file:t} validated (${duration}s)"
    return 0
  elif [[ $errors -eq 0 ]]; then
    _log_warning "${file:t} validated with $warnings warning(s) (${duration}s)"
    return 0  # Warnings don't block commit
  else
    _log_error "${file:t} validation failed: $errors error(s), $warnings warning(s) (${duration}s)"
    return 1
  fi
}

# ============================================================================
# MAIN HOOK EXECUTION
# ============================================================================

main() {
  local start_time=$(date +%s)

  echo ""
  _log_info "${COLORS[bold]}Pre-commit validation${COLORS[reset]}"
  echo ""

  # Special check: _freeze/ directory
  if ! _check_freeze; then
    return 1  # Hard fail - cannot proceed
  fi

  # Get staged .qmd files
  local qmd_files
  qmd_files=($(git diff --cached --name-only --diff-filter=ACM | grep '\.qmd$'))

  if [[ ${#qmd_files[@]} -eq 0 ]]; then
    _log_info "No .qmd files staged - skipping validation"
    return 0
  fi

  _log_info "Found ${#qmd_files[@]} .qmd file(s) to validate"
  echo ""

  # Validate each file
  local errors=0
  local warnings=0

  # Check if parallel rendering is enabled and we have multiple files
  if [[ "${QUARTO_PARALLEL_RENDER}" == "1" ]] && \
     [[ "${QUARTO_PRE_COMMIT_RENDER}" == "1" ]] && \
     [[ ${#qmd_files[@]} -gt 1 ]]; then

    # Validate YAML and syntax first (fast, sequential)
    for file in "${qmd_files[@]}"; do
      if ! _validate_yaml "$file"; then
        ((errors++))
      fi
      if ! _validate_syntax "$file"; then
        ((errors++))
      fi
    done

    # Early exit on errors
    if [[ $errors -gt 0 ]]; then
      _log_error "Validation failed with $errors error(s)"
      _prompt_commit_anyway "errors" || return 1
      return 0
    fi

    # Render in parallel
    if ! _render_files_parallel "${qmd_files[@]}"; then
      ((errors++))
    fi

    # Check for warnings (empty chunks, images) - sequential
    for file in "${qmd_files[@]}"; do
      _check_empty_chunks "$file" || ((warnings++))
      _check_images "$file" || ((warnings++))
    done
  else
    # Sequential validation
    for file in "${qmd_files[@]}"; do
      if ! _validate_file "$file"; then
        ((errors++))
      fi
    done
  fi

  local end_time=$(date +%s)
  local duration=$((end_time - start_time))

  echo ""

  # Save validation timing for prepare-commit-msg hook
  local timing_file="/tmp/flow-quarto-validation-timing-$$"
  echo "$duration" > "$timing_file"

  # Save validation summary if enabled
  if [[ "${QUARTO_COMMIT_SUMMARY}" == "1" ]]; then
    local summary_file="/tmp/flow-quarto-validation-summary-$$"
    if [[ $errors -gt 0 ]] || [[ $warnings -gt 0 ]]; then
      echo "${#qmd_files[@]} files validated: $errors error(s), $warnings warning(s)" > "$summary_file"
    else
      echo "${#qmd_files[@]} files validated successfully" > "$summary_file"
    fi
  fi

  # Final summary
  if [[ $errors -gt 0 ]]; then
    _log_error "Validation failed: $errors error(s), $warnings warning(s) (${duration}s total)"
    _prompt_commit_anyway "errors" || return 1
  elif [[ $warnings -gt 0 ]]; then
    _log_warning "Validation completed with $warnings warning(s) (${duration}s total)"
    _prompt_commit_anyway "warnings" || return 1
  else
    _log_success "All validations passed (${duration}s total)"
  fi

  return 0
}

# Execute main function
main
exit $?
